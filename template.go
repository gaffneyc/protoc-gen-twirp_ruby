package main

import (
	"bytes"
	"strings"
	"unicode"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

type rubyTemplatePresenter struct {
	proto *descriptor.FileDescriptorProto

	Version        string
	Package        string
	SourceFilename string
}

func (p *rubyTemplatePresenter) ModuleName() string {
	pkg := p.proto.GetPackage()
	if pkg == "" {
		pkg = "Twirp"
	}

	return camelize(pkg)
}

func (p *rubyTemplatePresenter) Messages() []*rtMessage {
	messages := make([]*rtMessage, len(p.proto.GetMessageType()))

	for i, msg := range p.proto.GetMessageType() {
		messages[i] = &rtMessage{
			proto: msg,
			pkg:   p.proto.GetPackage(),
		}
	}

	return messages
}

func (p *rubyTemplatePresenter) Services() []*rtService {
	services := make([]*rtService, len(p.proto.GetService()))

	for i, svc := range p.proto.GetService() {
		services[i] = &rtService{
			proto: svc,
			pkg:   p.proto.GetPackage(),
		}
	}

	return services
}

type rtMessage struct {
	proto *descriptor.DescriptorProto
	pkg   string
}

func (m *rtMessage) Name() string {
	return m.proto.GetName()
}

func (m *rtMessage) FullName() string {
	if m.pkg == "" {
		return m.proto.GetName()
	}

	return m.pkg + "." + m.proto.GetName()
}

type rtService struct {
	proto *descriptor.ServiceDescriptorProto
	pkg   string
}

func (svc *rtService) ClientName() string {
	return camelize(svc.proto.GetName()) + "Client"
}

func (svc *rtService) ServiceName() string {
	if svc.pkg == "" {
		return svc.proto.GetName()
	}

	return svc.pkg + "." + svc.proto.GetName()
}

func (svc *rtService) Methods() []*rtMethod {
	methods := make([]*rtMethod, len(svc.proto.GetMethod()))

	for i, proto := range svc.proto.GetMethod() {
		methods[i] = &rtMethod{
			proto: proto,
		}
	}

	return methods
}

type rtMethod struct {
	proto *descriptor.MethodDescriptorProto
}

func (m *rtMethod) Name() string {
	return m.proto.GetName()
}

func (m *rtMethod) MethodName() string {
	return underscore(m.proto.GetName())
}

func (m *rtMethod) InputArg() string {
	// name is prefixed with the package
	name := m.proto.GetInputType()
	parts := strings.Split(name, ".")

	return underscore(parts[len(parts)-1])
}

func (m *rtMethod) Deserializer() string {
	// name is prefixed with the package
	name := m.proto.GetOutputType()
	parts := strings.Split(name, ".")

	return parts[len(parts)-1]
}

// camelize converts snake_case to CamelCase
//
// This is a really nieve and probably wrong camelcase implementation
func camelize(input string) string {
	parts := strings.Split(input, ".")

	for i, part := range parts {
		words := strings.Split(part, "_")

		for j, word := range words {
			runed := []rune(word)
			runed[0] = unicode.ToUpper(runed[0])

			words[j] = string(runed)
		}

		parts[i] = strings.Join(words, "")
	}

	return strings.Join(parts, "::")
}

// underscore converts CamelCase to snake_case
func underscore(input string) string {
	buf := &bytes.Buffer{}

	// Iterate over the string. Lower case everything, and add an underscore
	// before any capital that's not the first.
	for i, char := range input {
		if unicode.IsUpper(char) && i > 0 {
			buf.WriteRune('_')
		}

		buf.WriteRune(unicode.ToLower(char))
	}

	return buf.String()
}

// rubyTemplate provides a full template for the generated Ruby code.
const rubyTemplate = `# Code generated by protoc-gen-twirp_ruby {{.Version}}, DO NOT EDIT.
# source: {{.SourceFilename}}

require "json"
require "net/https"
require "google/protobuf"

module {{ .ModuleName }}
  class Error < StandardError; end

  class ServiceError < Error
    attr_reader :code
    attr_reader :meta
    attr_reader :message

    def initialize(response)
      error = JSON.parse(response.body)

      @code    = error["code"]
      @meta    = error["meta"] || {}
      @message = error["msg"]
    end
  end

  {{ range .Messages }}{{ .Name }} ||= ::Google::Protobuf::DescriptorPool.generated_pool.lookup("{{ .FullName }}").msgclass
  {{ end }}

  {{ range .Services }}
  class {{ .ClientName }}
    attr_reader :service_name

    def initialize(server)
      @server       = URI.parse(server)
      @service_name = "{{ .ServiceName }}"
    end

    {{ range .Methods }}
    def {{ .MethodName }}({{ .InputArg }})
      body = {{ .InputArg }}.to_proto
      resp = make_request(body, "#{service_name}/{{ .Name }}")

      {{ .Deserializer }}.decode(resp.body)
    end
    {{ end }}

    def make_request(body, path)
      options = {
        use_ssl: @server.scheme == "https",
      }

      Net::HTTP.start(@server.host, @server.port, options) do |http|
        path    = "/twirp/#{path}"
        request = Net::HTTP::Post.new(path)
        request.body = body

        request["User-Agent"]   = user_agent
        request["Content-Type"] = "application/protobuf"

        # Authenticate with Basic Auth if a username or password was provided.
        if @server.user || @server.password
          request.basic_auth(url.user, url.password)
        end

        response = http.request(request)

        if !response.is_a?(Net::HTTPSuccess)
          raise ServiceError.new(response)
        end

        response
      end
    end

    def user_agent
      "#{RUBY_ENGINE}/#{RUBY_VERSION}; #{RUBY_PLATFORM}; v1.0.0"
    end
  end
  {{ end }}
end
`
